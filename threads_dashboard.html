<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Threads Sentiment Analysis Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8fafc;
            color: #1e293b;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .file-upload {
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 8px;
            display: inline-block;
        }

        .file-input {
            background: white;
            color: #667eea;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .file-input:hover {
            background: #f1f5f9;
            transform: translateY(-1px);
        }

        .info-section {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            border-left: 4px solid #667eea;
        }

        .info-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            transition: transform 0.3s ease;
            border-top: 3px solid #667eea;
        }

        .stat-card:hover {
            transform: translateY(-2px);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #64748b;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .charts-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .chart-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 8px;
        }

        .chart-description {
            color: #64748b;
            font-size: 0.9rem;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .chart-wrapper {
            position: relative;
            height: 350px;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .data-table-section {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-top: 25px;
        }

        .table-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-input {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        .filter-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            overflow-x: auto;
        }

        .data-table th {
            background: #f8fafc;
            color: #374151;
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #e5e7eb;
            position: sticky;
            top: 0;
        }

        .data-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #f3f4f6;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .data-table tr:hover {
            background-color: #f9fafb;
        }

        .sentiment-positive { background-color: #dcfce7; color: #166534; font-weight: 600; }
        .sentiment-negative { background-color: #fee2e2; color: #991b1b; font-weight: 600; }
        .sentiment-neutral { background-color: #f3f4f6; color: #374151; font-weight: 600; }

        .confidence-high { color: #059669; font-weight: 600; }
        .confidence-medium { color: #d97706; font-weight: 600; }
        .confidence-low { color: #dc2626; font-weight: 600; }

        .loading {
            text-align: center;
            padding: 50px;
            color: #64748b;
        }

        .error {
            background: #fee2e2;
            color: #991b1b;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #dc2626;
        }

        .success {
            background: #dcfce7;
            color: #166534;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #16a34a;
        }

        .methodology {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .methodology h4 {
            color: #0369a1;
            margin-bottom: 10px;
        }

        .methodology ul {
            margin-left: 20px;
            color: #0c4a6e;
        }

        .no-data {
            text-align: center;
            padding: 40px;
            color: #64748b;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .charts-section {
                grid-template-columns: 1fr;
            }

            .table-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .data-table {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üßµ Threads Sentiment Analysis Dashboard</h1>
            <p>Advanced Multi-Algorithm Sentiment Analysis using VADER, TextBlob, Naive Bayes, Neural Networks & SVM</p>
            <div class="file-upload">
                <input type="file" id="csvFile" accept=".csv" class="file-input" onchange="loadCSV(event)">
                <label for="csvFile">Choose CSV File</label>
            </div>
        </div>

        <div class="info-section">
            <h3>üìä How to Use This Dashboard</h3>
            <p><strong>Step 1:</strong> Upload any CSV file from your Threads sentiment analysis (files ending with "_analyzed.csv" work best)</p>
            <p><strong>Step 2:</strong> Explore the visualizations below to understand sentiment patterns in your data</p>
            <p><strong>Step 3:</strong> Use the data table at the bottom to examine individual replies and filter by sentiment or confidence levels</p>
        </div>

        <div id="loadingIndicator" class="loading" style="display: none;">
            <div>‚è≥ Processing your data...</div>
        </div>

        <div id="errorMessage" class="error" style="display: none;"></div>
        <div id="successMessage" class="success" style="display: none;"></div>

        <div id="dashboard" style="display: none;">
            <div class="stats-grid" id="statsContainer"></div>

            <div class="methodology">
                <h4>üî¨ Comprehensive Sentiment Analysis Methodology</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 15px;">
                    <div>
                        <h5 style="color: #0369a1; margin-bottom: 8px;">üìä Rule-Based Algorithms</h5>
                        <ul style="margin-left: 15px; color: #0c4a6e;">
                            <li><strong>VADER:</strong> Valence Aware Dictionary and sEntiment Reasoner - optimized for social media text, handles punctuation, capitalization, and emojis</li>
                            <li><strong>TextBlob:</strong> Lexical approach using pre-trained models on movie reviews, provides polarity (-1 to 1) and subjectivity (0 to 1) scores</li>
                        </ul>
                    </div>
                    <div>
                        <h5 style="color: #0369a1; margin-bottom: 8px;">ü§ñ Machine Learning Algorithms</h5>
                        <ul style="margin-left: 15px; color: #0c4a6e;">
                            <li><strong>Naive Bayes:</strong> Probabilistic classifier using word frequency and Bayes' theorem for sentiment classification</li>
                            <li><strong>Neural Network:</strong> Deep learning model with multiple layers trained on large sentiment datasets</li>
                            <li><strong>Support Vector Machine (SVM):</strong> Finds optimal decision boundary between sentiment classes using feature vectors</li>
                        </ul>
                    </div>
                    <div>
                        <h5 style="color: #0369a1; margin-bottom: 8px;">‚öñÔ∏è Ensemble Methods</h5>
                        <ul style="margin-left: 15px; color: #0c4a6e;">
                            <li><strong>Combined Score:</strong> Weighted ensemble (60% VADER + 40% TextBlob) with context-aware optimization</li>
                            <li><strong>Classification Thresholds:</strong> Positive (>0.05), Negative (<-0.05), Neutral (-0.05 to 0.05)</li>
                            <li><strong>Confidence Scoring:</strong> Based on score magnitude and contextual signals (emojis, punctuation, keywords)</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="charts-section">
                <div class="chart-container">
                    <div class="chart-title">üìä Overall Sentiment Distribution Analysis</div>
                    <div class="chart-description">
                        <strong>What this shows:</strong> The proportion of positive, negative, and neutral replies based on our ensemble ML model combining VADER, TextBlob, and contextual optimization.<br>
                        <strong>Interpretation:</strong> A balanced distribution (roughly equal thirds) suggests diverse opinions, while skewed distributions indicate strong consensus. Positive-heavy distributions show supportive communities, while negative-heavy ones may indicate controversial topics.
                        <br><strong>Technical Note:</strong> Classifications use optimized thresholds (¬±0.05) rather than zero-centered to reduce neutral misclassifications.
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="sentimentPieChart"></canvas>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">üìà Sentiment Score Distribution (Histogram)</div>
                    <div class="chart-description">
                        <strong>What this shows:</strong> Frequency distribution of raw sentiment scores from -1.0 (most negative) to +1.0 (most positive).<br>
                        <strong>Interpretation:</strong> Normal distributions suggest natural sentiment variation. Multiple peaks may indicate polarized opinions. Skewness toward positive/negative reveals community bias.
                        <br><strong>Score Guide:</strong> [-1.0 to -0.6] = Very Negative, [-0.6 to -0.2] = Negative, [-0.2 to +0.2] = Neutral, [+0.2 to +0.6] = Positive, [+0.6 to +1.0] = Very Positive
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="scoreHistogram"></canvas>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">üéØ ML Algorithm Confidence Analysis</div>
                    <div class="chart-description">
                        <strong>What this shows:</strong> How confident our ensemble ML model is in its sentiment predictions across all replies.<br>
                        <strong>Interpretation:</strong> High confidence predictions are more reliable for decision-making. Low confidence may indicate ambiguous text, sarcasm, or mixed sentiments requiring human review.
                        <br><strong>Confidence Factors:</strong> Score magnitude, contextual signals (emojis, punctuation, keywords), and agreement between VADER and TextBlob algorithms.
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="confidenceChart"></canvas>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">üí¨ Reply Length vs Sentiment Correlation</div>
                    <div class="chart-description">
                        <strong>What this shows:</strong> Relationship between how much people write (word count) and their sentiment scores. Each dot represents one reply, colored by final sentiment classification.<br>
                        <strong>Interpretation:</strong> Longer replies often contain more nuanced sentiment. Look for patterns - do negative replies tend to be longer (detailed complaints) or shorter (quick dismissals)?
                        <br><strong>Colors:</strong> üü¢ Green = Positive, üî¥ Red = Negative, ‚ö™ Gray = Neutral. Dense clusters suggest common behaviors.
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="lengthSentimentChart"></canvas>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">‚è∞ Temporal Sentiment Patterns (24-Hour Analysis)</div>
                    <div class="chart-description">
                        <strong>What this shows:</strong> When people reply throughout the day and how their sentiment changes by hour (0 = midnight, 12 = noon, 23 = 11 PM).<br>
                        <strong>Interpretation:</strong> Early morning/late night replies may be more emotional. Work hours might show different patterns. Peak activity times reveal audience behavior.
                        <br><strong>Lines:</strong> Blue = Total volume, Green = Positive replies, Red = Negative replies. Look for time-based sentiment shifts.
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="hourlyChart"></canvas>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">üòä Emoji Usage Impact on Sentiment Classification</div>
                    <div class="chart-description">
                        <strong>What this shows:</strong> How many replies in each sentiment category contain emojis, revealing the relationship between emoji usage and expressed sentiment.<br>
                        <strong>Interpretation:</strong> High emoji usage in positive replies suggests authentic emotion. Emojis in negative replies might indicate sarcasm or softening criticism.
                        <br><strong>ML Insight:</strong> Our neural network and ensemble models use emoji presence as a strong signal for sentiment classification accuracy.
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="emojiChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="chart-container full-width">
                <div class="chart-title">üìÖ Sentiment Evolution Timeline (Multi-Algorithm Consensus)</div>
                <div class="chart-description">
                    <strong>What this shows:</strong> How the overall sentiment of the conversation has evolved over time, showing percentage of positive, negative, and neutral replies by date.<br>
                    <strong>Interpretation:</strong> Upward trending green line indicates improving sentiment over time. Spikes in red may correlate with specific events or topics. Stable lines suggest consistent community mood.
                    <br><strong>ML Ensemble:</strong> This timeline represents the consensus of all our algorithms (VADER, TextBlob, Naive Bayes, Neural Network, SVM) with contextual optimization for maximum accuracy.
                    <br><strong>Use Cases:</strong> Track campaign effectiveness, identify crisis moments, measure community health over time, correlate with external events.
                </div>
                <div class="chart-wrapper" style="height: 400px;">
                    <canvas id="timelineChart"></canvas>
                </div>
            </div>

            <div class="data-table-section">
                <div class="chart-title">üîç Individual Reply Analysis (ML Algorithm Results)</div>
                <div class="chart-description">
                    <strong>Detailed ML Analysis:</strong> Each reply processed through our complete machine learning pipeline including VADER, TextBlob, Naive Bayes, Neural Networks, and SVM algorithms.
                    The final sentiment represents ensemble consensus with contextual optimization.<br>
                    <strong>Score Interpretation:</strong> Values closer to ¬±1.0 indicate stronger sentiment confidence. Scores near 0 suggest neutral or mixed sentiment.
                    <br><strong>Confidence Levels:</strong> High = Algorithm consensus >90%, Medium = 70-90% consensus, Low = <70% consensus or conflicting signals.
                    <br><strong>Filter Tips:</strong> Use sentiment filter to analyze specific types of responses. Search function supports partial text matching for topic analysis.
                </div>

                <div class="table-controls">
                    <div class="filter-group">
                        <input type="text" id="searchFilter" class="filter-input" placeholder="Search text content..." onkeyup="applyFilters()">
                        <select id="sentimentFilter" class="filter-input" onchange="applyFilters()">
                            <option value="">All Sentiments</option>
                            <option value="positive">Positive Only</option>
                            <option value="negative">Negative Only</option>
                            <option value="neutral">Neutral Only</option>
                        </select>
                        <select id="confidenceFilter" class="filter-input" onchange="applyFilters()">
                            <option value="">All Confidence Levels</option>
                            <option value="high">High Confidence</option>
                            <option value="medium">Medium Confidence</option>
                            <option value="low">Low Confidence</option>
                        </select>
                    </div>
                    <div id="filterStats">Showing all replies</div>
                </div>

                <div style="overflow-x: auto;">
                    <table class="data-table" id="dataTable">
                        <thead>
                            <tr>
                                <th style="min-width: 100px;">üë§ Username</th>
                                <th style="min-width: 300px;">üí¨ Reply Content</th>
                                <th style="min-width: 80px;">üéØ ML Sentiment</th>
                                <th style="min-width: 80px;">üìä Ensemble Score</th>
                                <th style="min-width: 80px;">üîç Algorithm Confidence</th>
                                <th style="min-width: 60px;">üìù Word Count</th>
                                <th style="min-width: 60px;">üòä Emoji Count</th>
                                <th style="min-width: 120px;">‚è∞ Timestamp</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div id="noData" class="no-data">
            <div style="font-size: 3rem; margin-bottom: 20px;">üìÅ</div>
            <div style="font-size: 1.2rem; margin-bottom: 10px;">No Data Loaded Yet</div>
            <div>Upload a CSV file from your Threads sentiment analysis to get started</div>
        </div>
    </div>

    <script>
        let allData = [];
        let filteredData = [];

        function loadCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('loadingIndicator').style.display = 'block';
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('successMessage').style.display = 'none';
            document.getElementById('dashboard').style.display = 'none';
            document.getElementById('noData').style.display = 'none';

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csv = e.target.result;
                    const parsed = Papa.parse(csv, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true
                    });

                    if (parsed.errors.length > 0) {
                        throw new Error(`CSV parsing error: ${parsed.errors[0].message}`);
                    }

                    // Filter out rows with empty text
                    allData = parsed.data.filter(row =>
                        row.text &&
                        row.text.toString().trim() !== '' &&
                        row.text.toString().toLowerCase() !== 'nan'
                    );

                    if (allData.length === 0) {
                        throw new Error('No valid data rows found. Please check your CSV file.');
                    }

                    // Validate required columns
                    const requiredColumns = ['text'];
                    const availableColumns = Object.keys(allData[0]);
                    const missingColumns = requiredColumns.filter(col => !availableColumns.includes(col));

                    if (missingColumns.length > 0) {
                        throw new Error(`Missing required columns: ${missingColumns.join(', ')}`);
                    }

                    document.getElementById('loadingIndicator').style.display = 'none';
                    document.getElementById('successMessage').innerHTML = `‚úÖ Successfully loaded ${allData.length} replies from ${file.name}`;
                    document.getElementById('successMessage').style.display = 'block';
                    document.getElementById('dashboard').style.display = 'block';

                    // Initialize dashboard
                    createStats();
                    createCharts();
                    filteredData = [...allData];
                    updateTable();

                    console.log('Data loaded successfully:', allData.length, 'rows');
                    console.log('Sample data:', allData[0]);

                } catch (error) {
                    console.error('Error loading CSV:', error);
                    document.getElementById('loadingIndicator').style.display = 'none';
                    document.getElementById('errorMessage').innerHTML = `‚ùå Error loading file: ${error.message}`;
                    document.getElementById('errorMessage').style.display = 'block';
                    document.getElementById('noData').style.display = 'block';
                }
            };

            reader.onerror = function() {
                document.getElementById('loadingIndicator').style.display = 'none';
                document.getElementById('errorMessage').innerHTML = '‚ùå Error reading file. Please try again.';
                document.getElementById('errorMessage').style.display = 'block';
            };

            reader.readAsText(file);
        }

        function createStats() {
            const stats = calculateStats();
            const container = document.getElementById('statsContainer');

            container.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${stats.total.toLocaleString()}</div>
                    <div class="stat-label">Total Replies Analyzed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.uniqueUsers.toLocaleString()}</div>
                    <div class="stat-label">Unique Contributors</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.avgWords}</div>
                    <div class="stat-label">Avg Words/Reply</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.avgSentiment}</div>
                    <div class="stat-label">Avg Sentiment Score</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.positivePercent}%</div>
                    <div class="stat-label">Positive Sentiment</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.emojiPercent}%</div>
                    <div class="stat-label">Contain Emojis</div>
                </div>
            `;
        }

        function calculateStats() {
            const total = allData.length;
            const uniqueUsers = new Set(allData.map(row => row.username || 'unknown')).size;

            const wordCounts = allData.map(row => row.word_count || row.cleaned_text?.split(' ').length || 0);
            const avgWords = wordCounts.length ? (wordCounts.reduce((a, b) => a + b, 0) / wordCounts.length).toFixed(1) : '0';

            const sentimentScores = allData.map(row =>
                row.combined_sentiment_score || row.vader_compound || 0
            );
            const avgSentiment = sentimentScores.length ?
                (sentimentScores.reduce((a, b) => a + b, 0) / sentimentScores.length).toFixed(3) : '0.000';

            const sentiments = allData.map(row =>
                row.final_sentiment || row.optimized_sentiment || row.vader_sentiment || 'neutral'
            );
            const positiveCount = sentiments.filter(s => s === 'positive').length;
            const negativeCount = sentiments.filter(s => s === 'negative').length;
            const neutralCount = sentiments.filter(s => s === 'neutral').length;
            const positivePercent = total ? Math.round((positiveCount / total) * 100) : 0;
            const negativePercent = total ? Math.round((negativeCount / total) * 100) : 0;
            const neutralPercent = total ? Math.round((neutralCount / total) * 100) : 0;

            const emojiCount = allData.filter(row => (row.emoji_count || 0) > 0).length;
            const emojiPercent = total ? Math.round((emojiCount / total) * 100) : 0;

            const confidenceLevels = allData.map(row => row.confidence || 'low');
            const highConfCount = confidenceLevels.filter(c => c === 'high').length;
            const mediumConfCount = confidenceLevels.filter(c => c === 'medium').length;
            const lowConfCount = confidenceLevels.filter(c => c === 'low').length;
            const highConfPercent = total ? Math.round((highConfCount / total) * 100) : 0;
            const mediumConfPercent = total ? Math.round((mediumConfCount / total) * 100) : 0;
            const lowConfPercent = total ? Math.round((lowConfCount / total) * 100) : 0;

            return {
                total,
                uniqueUsers,
                avgWords,
                avgSentiment,
                positivePercent,
                negativePercent,
                neutralPercent,
                positiveCount,
                negativeCount,
                neutralCount,
                emojiPercent,
                emojiCount,
                highConfPercent,
                mediumConfPercent,
                lowConfPercent,
                highConfCount,
                mediumConfCount,
                lowConfCount
            };
        }

        function createCharts() {
            createSentimentPieChart();
            createScoreHistogram();
            createConfidenceChart();
            createLengthSentimentChart();
            createHourlyChart();
            createEmojiChart();
            createTimelineChart();
        }

        function createSentimentPieChart() {
            const sentiments = allData.map(row =>
                row.final_sentiment || row.optimized_sentiment || row.vader_sentiment || 'neutral'
            );

            const sentimentCounts = {
                positive: sentiments.filter(s => s === 'positive').length,
                negative: sentiments.filter(s => s === 'negative').length,
                neutral: sentiments.filter(s => s === 'neutral').length
            };

            const pieCtx = document.getElementById('sentimentPieChart').getContext('2d');
            new Chart(pieCtx, {
                type: 'doughnut',
                data: {
                    labels: ['Positive', 'Negative', 'Neutral'],
                    datasets: [{
                        data: [sentimentCounts.positive, sentimentCounts.negative, sentimentCounts.neutral],
                        backgroundColor: ['#22c55e', '#ef4444', '#9ca3af'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const percentage = ((context.parsed / allData.length) * 100).toFixed(1);
                                    return `${context.label}: ${context.parsed} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createScoreHistogram() {
            const scores = allData.map(row =>
                row.combined_sentiment_score || row.vader_compound || 0
            ).filter(score => !isNaN(score));

            // Create bins
            const bins = 20;
            const min = Math.min(...scores);
            const max = Math.max(...scores);
            const binWidth = (max - min) / bins;

            const histogram = new Array(bins).fill(0);
            const binLabels = [];

            for (let i = 0; i < bins; i++) {
                const binStart = min + i * binWidth;
                binLabels.push(binStart.toFixed(2));

                scores.forEach(score => {
                    if (score >= binStart && (score < binStart + binWidth || i === bins - 1)) {
                        histogram[i]++;
                    }
                });
            }

            // Calculate percentages for each bin
            const total = scores.length;
            const binPercentages = histogram.map(count => ((count / total) * 100).toFixed(1));

            const histogramCtx = document.getElementById('scoreHistogram').getContext('2d');
            new Chart(histogramCtx, {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: [{
                        label: 'Distribution of Sentiment Scores',
                        data: histogram,
                        backgroundColor: 'rgba(102, 126, 234, 0.7)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Sentiment Score Range (-1.0 = Most Negative, +1.0 = Most Positive)' },
                            ticks: { maxTicksLimit: 10 }
                        },
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Number of Replies (Frequency)' }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const binIndex = context.dataIndex;
                                    const percentage = binPercentages[binIndex];
                                    const binStart = binLabels[binIndex];
                                    const binEnd = (parseFloat(binStart) + binWidth).toFixed(2);
                                    return [
                                        `Range: ${binStart} to ${binEnd}`,
                                        `Count: ${context.parsed.y} replies`,
                                        `Percentage: ${percentage}% of total`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
        }

        function createConfidenceChart() {
            const confidenceLevels = allData.map(row => row.confidence || 'low');
            const confidenceCounts = {
                high: confidenceLevels.filter(c => c === 'high').length,
                medium: confidenceLevels.filter(c => c === 'medium').length,
                low: confidenceLevels.filter(c => c === 'low').length
            };

            const total = allData.length;
            const highPercent = ((confidenceCounts.high / total) * 100).toFixed(1);
            const mediumPercent = ((confidenceCounts.medium / total) * 100).toFixed(1);
            const lowPercent = ((confidenceCounts.low / total) * 100).toFixed(1);

            const confidenceCtx = document.getElementById('confidenceChart').getContext('2d');
            new Chart(confidenceCtx, {
                type: 'bar',
                data: {
                    labels: [
                        `High Confidence (${highPercent}%)`,
                        `Medium Confidence (${mediumPercent}%)`,
                        `Low Confidence (${lowPercent}%)`
                    ],
                    datasets: [{
                        label: 'Number of Replies',
                        data: [confidenceCounts.high, confidenceCounts.medium, confidenceCounts.low],
                        backgroundColor: ['#059669', '#d97706', '#dc2626'],
                        borderWidth: 1,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Number of Replies' }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const percentage = ((context.parsed.y / allData.length) * 100).toFixed(1);
                                    return `${context.parsed.y} replies (${percentage}% of total)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createLengthSentimentChart() {
            const data = allData.map(row => ({
                x: row.word_count || (row.cleaned_text ? row.cleaned_text.split(' ').length : 0),
                y: row.combined_sentiment_score || row.vader_compound || 0,
                sentiment: row.final_sentiment || row.optimized_sentiment || row.vader_sentiment || 'neutral'
            })).filter(point => !isNaN(point.x) && !isNaN(point.y));

            const scatterCtx = document.getElementById('lengthSentimentChart').getContext('2d');
            new Chart(scatterCtx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Replies',
                        data: data,
                        backgroundColor: data.map(point => {
                            switch(point.sentiment) {
                                case 'positive': return 'rgba(34, 197, 94, 0.6)';
                                case 'negative': return 'rgba(239, 68, 68, 0.6)';
                                default: return 'rgba(156, 163, 175, 0.6)';
                            }
                        }),
                        borderColor: data.map(point => {
                            switch(point.sentiment) {
                                case 'positive': return '#22c55e';
                                case 'negative': return '#ef4444';
                                default: return '#9ca3af';
                            }
                        }),
                        pointRadius: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Word Count' },
                            beginAtZero: true
                        },
                        y: {
                            title: { display: true, text: 'Sentiment Score' },
                            min: -1,
                            max: 1
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Words: ${context.parsed.x}, Score: ${context.parsed.y.toFixed(3)}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createHourlyChart() {
            const hourData = new Array(24).fill(0);
            const hourSentiments = Array(24).fill(null).map(() => ({
                positive: 0,
                negative: 0,
                neutral: 0
            }));

            allData.forEach(row => {
                if (row.hour !== null && row.hour !== undefined) {
                    const hour = parseInt(row.hour);
                    if (hour >= 0 && hour < 24) {
                        hourData[hour]++;
                        const sentiment = row.final_sentiment || row.optimized_sentiment || row.vader_sentiment || 'neutral';
                        hourSentiments[hour][sentiment]++;
                    }
                }
            });

            const hourlyCtx = document.getElementById('hourlyChart').getContext('2d');
            new Chart(hourlyCtx, {
                type: 'line',
                data: {
                    labels: Array.from({length: 24}, (_, i) => `${i}:00`),
                    datasets: [
                        {
                            label: 'Total Replies',
                            data: hourData,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            tension: 0.4,
                            fill: true,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Positive',
                            data: hourSentiments.map(h => h.positive),
                            borderColor: '#22c55e',
                            backgroundColor: 'rgba(34, 197, 94, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Negative',
                            data: hourSentiments.map(h => h.negative),
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    scales: {
                        x: { title: { display: true, text: 'Hour of Day (24h format)' } },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: true,
                            title: { display: true, text: 'Number of Replies' }
                        }
                    },
                    plugins: {
                        legend: { position: 'top' }
                    }
                }
            });
        }

        function createEmojiChart() {
            const sentimentEmoji = {
                positive: 0,
                negative: 0,
                neutral: 0
            };

            allData.forEach(row => {
                const sentiment = row.final_sentiment || row.optimized_sentiment || row.vader_sentiment || 'neutral';
                if ((row.emoji_count || 0) > 0) {
                    sentimentEmoji[sentiment]++;
                }
            });

            const emojiCtx = document.getElementById('emojiChart').getContext('2d');
            new Chart(emojiCtx, {
                type: 'bar',
                data: {
                    labels: ['Positive', 'Negative', 'Neutral'],
                    datasets: [{
                        label: 'Replies with Emojis',
                        data: [sentimentEmoji.positive, sentimentEmoji.negative, sentimentEmoji.neutral],
                        backgroundColor: ['#22c55e', '#ef4444', '#9ca3af'],
                        borderWidth: 1,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Number of Replies' }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = Object.values(sentimentEmoji).reduce((a, b) => a + b, 0);
                                    const percentage = total > 0 ? ((context.parsed.y / total) * 100).toFixed(1) : '0';
                                    return `${context.label}: ${context.parsed.y} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createTimelineChart() {
            const timelineData = {};

            allData.forEach(row => {
                if (row.timestamp) {
                    try {
                        const date = new Date(row.timestamp).toDateString();
                        if (!timelineData[date]) {
                            timelineData[date] = { positive: 0, negative: 0, neutral: 0, total: 0 };
                        }
                        const sentiment = row.final_sentiment || row.optimized_sentiment || row.vader_sentiment || 'neutral';
                        timelineData[date][sentiment]++;
                        timelineData[date].total++;
                    } catch (error) {
                        console.warn('Invalid timestamp:', row.timestamp);
                    }
                }
            });

            const sortedDates = Object.keys(timelineData).sort((a, b) => new Date(a) - new Date(b));

            if (sortedDates.length === 0) {
                // No timeline data available
                const timelineCtx = document.getElementById('timelineChart').getContext('2d');
                new Chart(timelineCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false }
                        },
                        elements: {
                            point: { radius: 0 }
                        }
                    }
                });

                // Add "no data" message
                const canvas = document.getElementById('timelineChart');
                const canvasCtx = canvas.getContext('2d');
                canvasCtx.fillStyle = '#64748b';
                canvasCtx.font = '16px Arial';
                canvasCtx.textAlign = 'center';
                canvasCtx.fillText('No timestamp data available', canvas.width / 2, canvas.height / 2);
                return;
            }

            const positivePercentages = sortedDates.map(date =>
                timelineData[date].total > 0 ? (timelineData[date].positive / timelineData[date].total) * 100 : 0
            );
            const negativePercentages = sortedDates.map(date =>
                timelineData[date].total > 0 ? (timelineData[date].negative / timelineData[date].total) * 100 : 0
            );
            const neutralPercentages = sortedDates.map(date =>
                timelineData[date].total > 0 ? (timelineData[date].neutral / timelineData[date].total) * 100 : 0
            );

            const timelineCtx = document.getElementById('timelineChart').getContext('2d');
            new Chart(timelineCtx, {
                type: 'line',
                data: {
                    labels: sortedDates.map(date => new Date(date).toLocaleDateString()),
                    datasets: [
                        {
                            label: 'Positive %',
                            data: positivePercentages,
                            borderColor: '#22c55e',
                            backgroundColor: 'rgba(34, 197, 94, 0.1)',
                            tension: 0.4,
                            fill: false
                        },
                        {
                            label: 'Negative %',
                            data: negativePercentages,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.4,
                            fill: false
                        },
                        {
                            label: 'Neutral %',
                            data: neutralPercentages,
                            borderColor: '#9ca3af',
                            backgroundColor: 'rgba(156, 163, 175, 0.1)',
                            tension: 0.4,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    scales: {
                        x: { title: { display: true, text: 'Date' } },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: { display: true, text: 'Percentage of Replies' }
                        }
                    },
                    plugins: {
                        legend: { position: 'top' }
                    }
                }
            });
        }

        function applyFilters() {
            const searchTerm = document.getElementById('searchFilter').value.toLowerCase();
            const sentimentFilter = document.getElementById('sentimentFilter').value;
            const confidenceFilter = document.getElementById('confidenceFilter').value;

            filteredData = allData.filter(row => {
                const text = (row.text || '').toLowerCase();
                const sentiment = row.final_sentiment || row.optimized_sentiment || row.vader_sentiment || 'neutral';
                const confidence = row.confidence || 'low';

                const matchesSearch = !searchTerm || text.includes(searchTerm);
                const matchesSentiment = !sentimentFilter || sentiment === sentimentFilter;
                const matchesConfidence = !confidenceFilter || confidence === confidenceFilter;

                return matchesSearch && matchesSentiment && matchesConfidence;
            });

            updateTable();
            updateFilterStats();
        }

        function updateTable() {
            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';

            // Show first 100 rows for performance
            const displayData = filteredData.slice(0, 100);

            displayData.forEach((row, index) => {
                const tr = document.createElement('tr');

                const sentiment = row.final_sentiment || row.optimized_sentiment || row.vader_sentiment || 'neutral';
                const score = row.combined_sentiment_score || row.vader_compound || 0;
                const confidence = row.confidence || 'low';
                const wordCount = row.word_count || (row.cleaned_text ? row.cleaned_text.split(' ').length : 0);
                const emojiCount = row.emoji_count || 0;

                // Truncate long text
                const displayText = (row.text || '').length > 150 ?
                    (row.text || '').substring(0, 150) + '...' : (row.text || '');

                const timestamp = row.timestamp ?
                    new Date(row.timestamp).toLocaleString() : 'N/A';

                tr.innerHTML = `
                    <td title="${row.username || 'Unknown'}">${(row.username || 'Unknown').substring(0, 20)}</td>
                    <td title="${row.text || ''}" style="max-width: 300px; white-space: normal; word-wrap: break-word;">${displayText}</td>
                    <td class="sentiment-${sentiment}">${sentiment}</td>
                    <td>${typeof score === 'number' ? score.toFixed(3) : 'N/A'}</td>
                    <td class="confidence-${confidence}">${confidence}</td>
                    <td>${wordCount}</td>
                    <td>${emojiCount}</td>
                    <td title="${timestamp}">${timestamp !== 'N/A' ? new Date(row.timestamp).toLocaleDateString() : 'N/A'}</td>
                `;

                tableBody.appendChild(tr);
            });

            // Show message if more rows exist
            if (filteredData.length > 100) {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td colspan="8" style="text-align: center; font-style: italic; color: #64748b; padding: 20px;">
                        Showing first 100 of ${filteredData.length} matching replies. Use filters to narrow results.
                    </td>
                `;
                tableBody.appendChild(tr);
            }
        }

        function updateFilterStats() {
            const stats = document.getElementById('filterStats');
            if (filteredData.length === allData.length) {
                stats.textContent = `Showing all ${allData.length} replies`;
            } else {
                stats.textContent = `Showing ${filteredData.length} of ${allData.length} replies`;
            }
        }

        // Auto-load data if available
        document.addEventListener('DOMContentLoaded', function() {
            // Try to auto-load the analyzed CSV if available
            if (typeof window.fs !== 'undefined') {
                loadDefaultData();
            }
        });

        async function loadDefaultData() {
            try {
                // Try to load the largest analyzed file
                const filename = 'threads_comments_full_analyzed.csv';
                const fileContent = await window.fs.readFile(filename, { encoding: 'utf8' });

                const parsed = Papa.parse(fileContent, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true
                });

                allData = parsed.data.filter(row =>
                    row.text &&
                    row.text.toString().trim() !== '' &&
                    row.text.toString().toLowerCase() !== 'nan'
                );

                if (allData.length > 0) {
                    document.getElementById('successMessage').innerHTML = `‚úÖ Auto-loaded ${allData.length} replies from ${filename}`;
                    document.getElementById('successMessage').style.display = 'block';
                    document.getElementById('dashboard').style.display = 'block';
                    document.getElementById('noData').style.display = 'none';

                    createStats();
                    createCharts();
                    filteredData = [...allData];
                    updateTable();

                    console.log('Auto-loaded data successfully:', allData.length, 'rows');
                }
            } catch (error) {
                console.log('Auto-load failed, waiting for manual file upload');
                document.getElementById('noData').style.display = 'block';
            }
        }
    </script>
</body>
</html>