<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ensemble Analytics Dashboard</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- Chart.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

  <!-- PapaParse -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    .method-card {
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }
    .method-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    }
    .method-card.winner {
      border-color: #22c55e;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.05), white);
    }
    .agreement-cell {
      transition: background-color 0.2s ease;
    }
    .disagreement-highlight {
      background-color: #fef2f2 !important;
      border: 1px solid #fca5a5;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
  <div id="root"></div>

  <script>
    const { useState, useEffect, useMemo, useRef } = React;

    function normalizeLabel(val) {
      if (!val) return null;
      const s = String(val).trim().toLowerCase();
      if (["pos", "+", "positive"].includes(s)) return "positive";
      if (["neg", "-", "negative"].includes(s)) return "negative";
      if (["neu", "neutral", "0"].includes(s)) return "neutral";
      return s;
    }

    function computeAccuracy(predictions, trueLabels) {
      if (!predictions || !trueLabels) return 0;

      let correct = 0;
      let total = 0;

      for (let i = 0; i < Math.min(predictions.length, trueLabels.length); i++) {
        const pred = normalizeLabel(predictions[i]);
        const truth = normalizeLabel(trueLabels[i]);
        if (pred && truth) {
          total++;
          if (pred === truth) correct++;
        }
      }

      return total > 0 ? correct / total : 0;
    }

    function computeF1Score(predictions, trueLabels) {
      if (!predictions || !trueLabels) return 0;

      const labels = ['positive', 'neutral', 'negative'];
      const metrics = {};

      // Initialize confusion matrix
      const confusion = {};
      labels.forEach(label => {
        confusion[label] = { positive: 0, neutral: 0, negative: 0 };
      });

      // Fill confusion matrix
      let totalValid = 0;
      for (let i = 0; i < Math.min(predictions.length, trueLabels.length); i++) {
        const pred = normalizeLabel(predictions[i]);
        const truth = normalizeLabel(trueLabels[i]);
        if (pred && truth && labels.includes(pred) && labels.includes(truth)) {
          confusion[truth][pred]++;
          totalValid++;
        }
      }

      if (totalValid === 0) return 0;

      // Calculate per-class metrics
      let weightedF1 = 0;
      labels.forEach(label => {
        const tp = confusion[label][label];
        const fp = labels.reduce((sum, l) => sum + (l !== label ? confusion[l][label] : 0), 0);
        const fn = labels.reduce((sum, l) => sum + (l !== label ? confusion[label][l] : 0), 0);

        const precision = tp + fp > 0 ? tp / (tp + fp) : 0;
        const recall = tp + fn > 0 ? tp / (tp + fn) : 0;
        const f1 = precision + recall > 0 ? 2 * precision * recall / (precision + recall) : 0;

        const support = labels.reduce((sum, l) => sum + confusion[label][l], 0);
        weightedF1 += f1 * (support / totalValid);
      });

      return weightedF1;
    }

    function computeAgreement(pred1, pred2) {
      if (!pred1 || !pred2) return 0;

      let agreements = 0;
      let total = 0;

      for (let i = 0; i < Math.min(pred1.length, pred2.length); i++) {
        const p1 = normalizeLabel(pred1[i]);
        const p2 = normalizeLabel(pred2[i]);
        if (p1 && p2) {
          total++;
          if (p1 === p2) agreements++;
        }
      }

      return total > 0 ? agreements / total : 0;
    }

    // Chart Components
    function PerformanceRadarChart({ methods }) {
      const canvasRef = useRef(null);
      const chartRef = useRef(null);

      useEffect(() => {
        if (!canvasRef.current || !methods.length) return;

        if (chartRef.current) {
          chartRef.current.destroy();
        }

        const ctx = canvasRef.current.getContext('2d');
        const colors = [
          '#22c55e', '#3b82f6', '#ef4444', '#f59e0b', '#8b5cf6', '#06b6d4', '#ec4899'
        ];

        chartRef.current = new Chart(ctx, {
          type: 'radar',
          data: {
            labels: ['Accuracy', 'F1-Score', 'Precision', 'Recall'],
            datasets: methods.slice(0, 5).map((method, index) => ({
              label: method.name,
              data: [
                method.accuracy * 100,
                method.f1Score * 100,
                (method.precision || 0) * 100,
                (method.recall || 0) * 100
              ],
              borderColor: colors[index],
              backgroundColor: colors[index] + '20',
              borderWidth: 2,
              pointBackgroundColor: colors[index],
              pointBorderColor: '#fff',
              pointBorderWidth: 2
            }))
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              r: {
                beginAtZero: true,
                max: 100,
                ticks: {
                  callback: function(value) {
                    return value + '%';
                  }
                }
              }
            },
            plugins: {
              legend: {
                position: 'bottom'
              }
            }
          }
        });

        return () => {
          if (chartRef.current) {
            chartRef.current.destroy();
          }
        };
      }, [methods]);

      return React.createElement('canvas', { ref: canvasRef });
    }

    function AgreementHeatmap({ agreementMatrix }) {
      if (!agreementMatrix.length) return React.createElement('div', { className: 'text-center text-gray-500' }, 'No agreement data available');

      return React.createElement('div', { className: 'overflow-x-auto' }, [
        React.createElement('table', { key: 'agreement-table', className: 'w-full text-sm' }, [
          React.createElement('thead', { key: 'agreement-thead' }, [
            React.createElement('tr', { key: 'agreement-header' }, [
              React.createElement('th', { key: 'corner', className: 'p-2 text-left' }, ''),
              ...agreementMatrix.map((_, i) =>
                React.createElement('th', { key: `header-${i}`, className: 'p-2 text-center text-xs' },
                  agreementMatrix[i].name.replace(/_/g, ' ')
                )
              )
            ])
          ]),
          React.createElement('tbody', { key: 'agreement-tbody' },
            agreementMatrix.map((row, i) =>
              React.createElement('tr', { key: `row-${i}` }, [
                React.createElement('td', { key: `label-${i}`, className: 'p-2 font-medium text-xs' },
                  row.name.replace(/_/g, ' ')
                ),
                ...row.agreements.map((agreement, j) => {
                  const intensity = Math.round(agreement * 255);
                  const bgColor = i === j ? '#e5e7eb' :
                    agreement > 0.8 ? '#dcfce7' :
                    agreement > 0.6 ? '#fef3c7' : '#fee2e2';

                  return React.createElement('td', {
                    key: `cell-${i}-${j}`,
                    className: 'p-2 text-center text-xs font-semibold agreement-cell',
                    style: { backgroundColor: bgColor }
                  }, i === j ? '-' : (agreement * 100).toFixed(0) + '%');
                })
              ])
            )
          )
        ])
      ]);
    }

    function MethodComparisonCard({ method, isWinner, onSelect, isSelected }) {
      const cardClass = `method-card p-6 bg-white rounded-lg shadow-md cursor-pointer ${
        isWinner ? 'winner' : ''
      } ${isSelected ? 'ring-2 ring-blue-500' : ''}`;

      return React.createElement('div', {
        className: cardClass,
        onClick: () => onSelect(method.name)
      }, [
        React.createElement('div', { key: 'method-header', className: 'flex items-center justify-between mb-4' }, [
          React.createElement('h3', { key: 'method-title', className: 'text-lg font-semibold text-gray-800' },
            method.name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
          ),
          isWinner && React.createElement('span', { key: 'winner-badge', className: 'bg-green-500 text-white px-2 py-1 rounded-full text-xs font-bold' }, '👑 BEST')
        ]),
        React.createElement('div', { key: 'method-metrics', className: 'space-y-3' }, [
          React.createElement('div', { key: 'accuracy-metric', className: 'flex justify-between items-center' }, [
            React.createElement('span', { key: 'acc-label', className: 'text-sm text-gray-600' }, 'Accuracy'),
            React.createElement('span', { key: 'acc-value', className: 'font-bold text-blue-600' },
              `${(method.accuracy * 100).toFixed(1)}%`
            )
          ]),
          React.createElement('div', { key: 'f1-metric', className: 'flex justify-between items-center' }, [
            React.createElement('span', { key: 'f1-label', className: 'text-sm text-gray-600' }, 'F1-Score'),
            React.createElement('span', { key: 'f1-value', className: 'font-bold text-green-600' },
              `${(method.f1Score * 100).toFixed(1)}%`
            )
          ]),
          React.createElement('div', { key: 'samples-metric', className: 'flex justify-between items-center' }, [
            React.createElement('span', { key: 'samples-label', className: 'text-sm text-gray-600' }, 'Samples'),
            React.createElement('span', { key: 'samples-value', className: 'font-bold text-purple-600' },
              method.totalSamples?.toLocaleString() || '0'
            )
          ])
        ])
      ]);
    }

    function DisagreementAnalysis({ rows, selectedMethod }) {
      const disagreements = useMemo(() => {
        if (!rows.length || !selectedMethod) return [];

        const baseModels = ['ml_sentiment_roberta', 'ml_sentiment_gb'];
        const ensembleCol = `ensemble_${selectedMethod}`;

        if (!rows[0][ensembleCol]) return [];

        return rows.filter((row, index) => {
          const ensemble = normalizeLabel(row[ensembleCol]);
          const roberta = normalizeLabel(row['ml_sentiment_roberta']);
          const gb = normalizeLabel(row['ml_sentiment_gb']);

          return ensemble && roberta && gb &&
                 (ensemble !== roberta || ensemble !== gb || roberta !== gb);
        }).slice(0, 20); // Show top 20 disagreements
      }, [rows, selectedMethod]);

      if (!disagreements.length) {
        return React.createElement('div', { className: 'text-center text-gray-500 py-8' },
          'No disagreements found or method not selected'
        );
      }

      return React.createElement('div', { className: 'space-y-3 max-h-96 overflow-y-auto' },
        disagreements.map((row, idx) => {
          const ensemble = normalizeLabel(row[`ensemble_${selectedMethod}`]);
          const roberta = normalizeLabel(row['ml_sentiment_roberta']);
          const gb = normalizeLabel(row['ml_sentiment_gb']);
          const manual = normalizeLabel(row['manual_sentiment_roberta'] || row['manual_sentiment_gb'] || row['manual_sentiment']);

          const getSentimentColor = (sentiment) => {
            switch(sentiment) {
              case 'positive': return 'text-green-600 bg-green-50 border-green-200';
              case 'negative': return 'text-red-600 bg-red-50 border-red-200';
              case 'neutral': return 'text-gray-600 bg-gray-50 border-gray-200';
              default: return 'text-gray-500 bg-gray-100 border-gray-200';
            }
          };

          return React.createElement('div', { key: `disagreement-${idx}`, className: 'disagreement-highlight p-4 rounded-lg' }, [
            React.createElement('p', { key: `text-${idx}`, className: 'text-gray-800 mb-3 text-sm' },
              (row.text || '(no text)').slice(0, 150) + (row.text && row.text.length > 150 ? '...' : '')
            ),
            React.createElement('div', { key: `predictions-${idx}`, className: 'flex flex-wrap gap-2 text-xs' }, [
              React.createElement('span', {
                key: `ensemble-${idx}`,
                className: `px-2 py-1 rounded border font-semibold ${getSentimentColor(ensemble)}`
              }, `Ensemble: ${ensemble || 'N/A'}`),
              React.createElement('span', {
                key: `roberta-${idx}`,
                className: `px-2 py-1 rounded border ${getSentimentColor(roberta)}`
              }, `RoBERTa: ${roberta || 'N/A'}`),
              React.createElement('span', {
                key: `gb-${idx}`,
                className: `px-2 py-1 rounded border ${getSentimentColor(gb)}`
              }, `GB: ${gb || 'N/A'}`),
              manual && React.createElement('span', {
                key: `manual-${idx}`,
                className: 'px-2 py-1 rounded border bg-blue-50 text-blue-600 border-blue-200 font-semibold'
              }, `True: ${manual}`)
            ])
          ]);
        })
      );
    }

    function EnsembleDashboard() {
      const [rows, setRows] = useState([]);
      const [filename, setFilename] = useState("");
      const [loading, setLoading] = useState(false);
      const [selectedMethod, setSelectedMethod] = useState("");

      const ensembleMethods = useMemo(() => {
        if (!rows.length) return [];

        const methods = [];
        const ensembleColumns = Object.keys(rows[0] || {}).filter(key => key.startsWith('ensemble_'));

        // Also include base models
        const baseModels = [
          { key: 'ml_sentiment_roberta', name: 'roberta_base' },
          { key: 'ml_sentiment_gb', name: 'gradient_boosting_base' }
        ];

        // Get ground truth column
        let groundTruth = null;
        for (const col of ['manual_sentiment_roberta', 'manual_sentiment_gb', 'manual_sentiment']) {
          if (rows[0][col]) {
            groundTruth = rows.map(row => row[col]);
            break;
          }
        }

        // Process ensemble methods
        ensembleColumns.forEach(col => {
          const methodName = col.replace('ensemble_', '');
          const predictions = rows.map(row => row[col]);

          methods.push({
            name: methodName,
            predictions,
            accuracy: groundTruth ? computeAccuracy(predictions, groundTruth) : 0,
            f1Score: groundTruth ? computeF1Score(predictions, groundTruth) : 0,
            totalSamples: rows.length,
            isEnsemble: true
          });
        });

        // Process base models
        baseModels.forEach(({ key, name }) => {
          if (rows[0][key]) {
            const predictions = rows.map(row => row[key]);
            methods.push({
              name,
              predictions,
              accuracy: groundTruth ? computeAccuracy(predictions, groundTruth) : 0,
              f1Score: groundTruth ? computeF1Score(predictions, groundTruth) : 0,
              totalSamples: rows.length,
              isEnsemble: false
            });
          }
        });

        return methods.sort((a, b) => b.f1Score - a.f1Score);
      }, [rows]);

      const agreementMatrix = useMemo(() => {
        if (!ensembleMethods.length) return [];

        return ensembleMethods.map(method1 => ({
          name: method1.name,
          agreements: ensembleMethods.map(method2 =>
            computeAgreement(method1.predictions, method2.predictions)
          )
        }));
      }, [ensembleMethods]);

      const winner = ensembleMethods.length > 0 ? ensembleMethods[0] : null;

      function handleFileUpload(file) {
        if (!file) return;
        setFilename(file.name);
        setLoading(true);

        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (res) => {
            const parsed = res.data.map(r => ({
              ...r,
              // Normalize all sentiment columns
              ml_sentiment_roberta: normalizeLabel(r.ml_sentiment_roberta),
              ml_sentiment_gb: normalizeLabel(r.ml_sentiment_gb),
              manual_sentiment: normalizeLabel(r.manual_sentiment || r.manual_sentiment_roberta || r.manual_sentiment_gb)
            }));
            setRows(parsed);
            setLoading(false);
            // Auto-select best method
            if (parsed.length > 0) {
              const ensembleCols = Object.keys(parsed[0]).filter(k => k.startsWith('ensemble_'));
              if (ensembleCols.length > 0) {
                setSelectedMethod(ensembleCols[0].replace('ensemble_', ''));
              }
            }
          },
          error: (error) => {
            console.error("CSV parsing error:", error);
            setLoading(false);
          }
        });
      }

      return React.createElement('div', { className: 'max-w-7xl mx-auto p-6' }, [
        // Header
        React.createElement('div', { key: 'header', className: 'mb-8' }, [
          React.createElement('div', { key: 'title-section', className: 'text-center mb-6' }, [
            React.createElement('h1', { key: 'main-title', className: 'text-4xl font-bold text-gray-800 mb-2' }, '🤖 Ensemble Analytics Dashboard'),
            React.createElement('p', { key: 'subtitle', className: 'text-lg text-gray-600' }, 'RoBERTa Social + Gradient Boosting Ensemble Analysis')
          ]),

          React.createElement('div', { key: 'file-upload', className: 'flex items-center justify-center gap-4 mb-4' }, [
            React.createElement('input', {
              key: 'file-input',
              type: 'file',
              accept: '.csv',
              onChange: (e) => handleFileUpload(e.target.files[0]),
              className: 'block w-full max-w-md text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100'
            }),
            loading && React.createElement('div', { key: 'loading', className: 'text-blue-600' }, '⏳ Loading...')
          ]),

          filename && React.createElement('p', { key: 'filename', className: 'text-center text-gray-600' },
            `📄 Loaded: ${filename} (${rows.length} rows)`
          )
        ]),

        // Winner Announcement
        winner && React.createElement('div', { key: 'winner', className: 'bg-gradient-to-r from-green-500 to-emerald-600 text-white p-6 rounded-xl shadow-lg mb-8 text-center' }, [
          React.createElement('h2', { key: 'winner-title', className: 'text-2xl font-bold mb-2' },
            `🏆 Best Method: ${winner.name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`
          ),
          React.createElement('div', { key: 'winner-stats', className: 'flex justify-center gap-8 text-lg' }, [
            React.createElement('div', { key: 'winner-acc' }, `Accuracy: ${(winner.accuracy * 100).toFixed(1)}%`),
            React.createElement('div', { key: 'winner-f1' }, `F1-Score: ${(winner.f1Score * 100).toFixed(1)}%`),
            React.createElement('div', { key: 'winner-type' }, winner.isEnsemble ? 'Ensemble Method' : 'Base Model')
          ])
        ]),

        // Method Comparison Cards
        ensembleMethods.length > 0 && React.createElement('div', { key: 'methods-section', className: 'mb-8' }, [
          React.createElement('h2', { key: 'methods-title', className: 'text-2xl font-semibold mb-6 text-gray-800' }, '📊 Method Performance Comparison'),
          React.createElement('div', { key: 'methods-grid', className: 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4' },
            ensembleMethods.map((method, index) =>
              React.createElement(MethodComparisonCard, {
                key: `method-${index}`,
                method,
                isWinner: method === winner,
                onSelect: setSelectedMethod,
                isSelected: selectedMethod === method.name
              })
            )
          )
        ]),

        // Charts Section
        ensembleMethods.length > 0 && React.createElement('div', { key: 'charts-section', className: 'grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8' }, [
          // Performance Radar
          React.createElement('div', { key: 'radar-chart', className: 'bg-white p-6 rounded-lg shadow-md' }, [
            React.createElement('h3', { key: 'radar-title', className: 'text-lg font-semibold mb-4 text-gray-800' }, '🎯 Performance Comparison'),
            React.createElement('div', { key: 'radar-container', className: 'h-80' }, [
              React.createElement(PerformanceRadarChart, { key: 'radar', methods: ensembleMethods })
            ])
          ]),

          // Agreement Heatmap
          React.createElement('div', { key: 'agreement-chart', className: 'bg-white p-6 rounded-lg shadow-md' }, [
            React.createElement('h3', { key: 'agreement-title', className: 'text-lg font-semibold mb-4 text-gray-800' }, '🤝 Model Agreement Matrix'),
            React.createElement('div', { key: 'agreement-container', className: 'h-80 overflow-auto' }, [
              React.createElement(AgreementHeatmap, { key: 'heatmap', agreementMatrix })
            ])
          ])
        ]),

        // Detailed Analysis
        selectedMethod && React.createElement('div', { key: 'detailed-analysis', className: 'bg-white p-6 rounded-lg shadow-md mb-8' }, [
          React.createElement('h3', { key: 'analysis-title', className: 'text-lg font-semibold mb-4 text-gray-800' },
            `🔍 Disagreement Analysis: ${selectedMethod.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`
          ),
          React.createElement('p', { key: 'analysis-description', className: 'text-gray-600 mb-4' },
            'Cases where ensemble and base models disagree (showing first 20 disagreements)'
          ),
          React.createElement(DisagreementAnalysis, { key: 'disagreement-analysis', rows, selectedMethod })
        ]),

        // Summary Statistics
        ensembleMethods.length > 0 && React.createElement('div', { key: 'summary-stats', className: 'bg-white p-6 rounded-lg shadow-md' }, [
          React.createElement('h3', { key: 'stats-title', className: 'text-lg font-semibold mb-4 text-gray-800' }, '📈 Performance Summary'),
          React.createElement('div', { key: 'stats-table', className: 'overflow-x-auto' }, [
            React.createElement('table', { key: 'summary-table', className: 'w-full text-sm' }, [
              React.createElement('thead', { key: 'summary-thead' }, [
                React.createElement('tr', { key: 'summary-header', className: 'border-b' }, [
                  React.createElement('th', { key: 'header-method', className: 'text-left py-2' }, 'Method'),
                  React.createElement('th', { key: 'header-type', className: 'text-left py-2' }, 'Type'),
                  React.createElement('th', { key: 'header-accuracy', className: 'text-right py-2' }, 'Accuracy'),
                  React.createElement('th', { key: 'header-f1', className: 'text-right py-2' }, 'F1-Score'),
                  React.createElement('th', { key: 'header-samples', className: 'text-right py-2' }, 'Samples')
                ])
              ]),
              React.createElement('tbody', { key: 'summary-tbody' },
                ensembleMethods.map((method, index) =>
                  React.createElement('tr', { key: `summary-row-${index}`, className: `border-b ${method === winner ? 'bg-green-50' : ''}` }, [
                    React.createElement('td', { key: `method-name-${index}`, className: 'py-2 font-medium' },
                      method.name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) +
                      (method === winner ? ' 🏆' : '')
                    ),
                    React.createElement('td', { key: `method-type-${index}`, className: 'py-2' },
                      method.isEnsemble ? 'Ensemble' : 'Base Model'
                    ),
                    React.createElement('td', { key: `method-acc-${index}`, className: 'text-right py-2' },
                      `${(method.accuracy * 100).toFixed(1)}%`
                    ),
                    React.createElement('td', { key: `method-f1-${index}`, className: 'text-right py-2' },
                      `${(method.f1Score * 100).toFixed(1)}%`
                    ),
                    React.createElement('td', { key: `method-samples-${index}`, className: 'text-right py-2' },
                      method.totalSamples?.toLocaleString() || '0'
                    )
                  ])
                )
              )
            ])
          ])
        ])
      ]);
    }

    // Render the app
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot ? ReactDOM.createRoot(container) : null;

    if (root) {
      root.render(React.createElement(EnsembleDashboard));
    } else {
      ReactDOM.render(React.createElement(EnsembleDashboard), container);
    }
  </script>
</body>
</html>