<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Algorithm Analysis Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        /* SASS-inspired styling converted to CSS */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        #container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header Styles */
        header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        header p {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 20px;
        }

        /* File Upload Styles */
        #csvFile {
            display: none;
        }

        label[for="csvFile"] {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.3s ease;
        }

        label[for="csvFile"]:hover {
            transform: translateY(-2px);
        }

        /* Loading and Error States */
        #loading, #error {
            text-align: center;
            padding: 40px;
            margin: 20px 0;
            border-radius: 10px;
            font-size: 1.1rem;
        }

        #loading {
            background: rgba(255, 255, 255, 0.9);
            color: #667eea;
        }

        #error {
            background: #ef4444;
            color: white;
        }

        /* Section Styles */
        section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            min-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        section h2 {
            font-size: 2rem;
            margin-bottom: 10px;
            color: #667eea;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        /* Summary Stats Grid */
        #summaryStats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-item {
            background: #f8fafc;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #667eea;
        }

        .stat-label {
            font-weight: 600;
            color: #666;
            display: block;
            margin-bottom: 5px;
        }

        .stat-item span:last-child {
            font-size: 1.5rem;
            font-weight: 700;
            color: #333;
        }

        /* Metrics Grid */
        #metricsGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 20px;
        }

        .metric-card {
            background: #f8fafc;
            border-radius: 12px;
            padding: 25px;
            border: 2px solid #e2e8f0;
        }

        .metric-card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .metric-card p {
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .metric-card span {
            font-weight: 600;
            color: #333;
        }

        /* Chart Section Layout */
        #chartsSection {
            min-height: auto;
        }

        .charts-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
            min-height: 70vh;
        }

        .chart-container {
            background: #f8fafc;
            border-radius: 12px;
            padding: 25px;
            border: 2px solid #e2e8f0;
            display: flex;
            flex-direction: column;
        }

        .chart-container h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.4rem;
        }

        .chart-description {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 20px;
            line-height: 1.5;
            font-style: italic;
        }

        .chart-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 10px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px 10px;
            border-bottom: 1px solid #e2e8f0;
            vertical-align: top;
        }

        tr:nth-child(even) {
            background: #f8fafc;
        }

        tr:hover {
            background: #e0f2fe;
        }

        /* Insights Styles */
        .insight-item {
            background: #f8fafc;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .insight-item h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .insight-item p {
            color: #555;
            line-height: 1.6;
        }

        /* Section Navigation Hint */
        .section-nav {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #container {
                padding: 15px;
            }

            header h1 {
                font-size: 2rem;
            }

            .charts-row {
                grid-template-columns: 1fr;
                gap: 20px;
                min-height: auto;
            }

            section {
                padding: 20px;
                min-height: auto;
            }

            #summaryStats, #metricsGrid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <header>
            <h1>üß† ML Algorithm Deep Dive</h1>
            <p>Comprehensive analysis of individual machine learning algorithm performance, confidence patterns, and decision-making behavior</p>
            <input type="file" id="csvFile" accept=".csv">
            <label for="csvFile">üìä Upload Algorithm Results CSV</label>
            <p style="margin-top: 15px; font-size: 0.9rem; color: #888;">
                Compatible with any ML output containing predictions and confidence scores
            </p>
        </header>

        <div id="loading" style="display: none;">
            <p>üîç Loading and analyzing your algorithm's predictions...</p>
        </div>

        <div id="error" style="display: none;"></div>

        <div id="content" style="display: none;">

            <!-- Algorithm Summary -->
            <section id="algorithmSummary">
                <h2>üìã Algorithm Overview</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    High-level summary of your algorithm's characteristics and overall performance metrics.
                </p>
                <div id="summaryStats">
                    <div class="stat-item">
                        <span class="stat-label">Algorithm Name</span>
                        <span id="algorithmName">Loading...</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Algorithm Type</span>
                        <span id="algorithmType">Loading...</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Total Predictions</span>
                        <span id="totalPredictions">Loading...</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Average Confidence</span>
                        <span id="avgConfidence">Loading...</span>
                    </div>
                </div>
            </section>

            <!-- Performance Metrics -->
            <section id="performanceMetrics">
                <h2>üìä Performance Breakdown</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    Detailed analysis of how your algorithm distributes its predictions and confidence levels across different categories and text features.
                </p>
                <div id="metricsGrid">
                    <div class="metric-card">
                        <h3>üéØ Confidence Distribution</h3>
                        <p style="color: #666; font-size: 0.9rem; margin-bottom: 15px;">
                            How certain the algorithm is about its predictions
                        </p>
                        <div>
                            <p>High Confidence (>80%): <span id="highConfidence">0</span></p>
                            <p>Medium Confidence (50-80%): <span id="mediumConfidence">0</span></p>
                            <p>Low Confidence (<50%): <span id="lowConfidence">0</span></p>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3>üí≠ Sentiment Distribution</h3>
                        <p style="color: #666; font-size: 0.9rem; margin-bottom: 15px;">
                            How the algorithm classifies overall sentiment
                        </p>
                        <div>
                            <p>Positive: <span id="positiveCount">0</span></p>
                            <p>Negative: <span id="negativeCount">0</span></p>
                            <p>Neutral: <span id="neutralCount">0</span></p>
                        </div>
                    </div>
                    <div class="metric-card">
                        <h3>üìù Text Feature Analysis</h3>
                        <p style="color: #666; font-size: 0.9rem; margin-bottom: 15px;">
                            Characteristics of the text data processed
                        </p>
                        <div>
                            <p>Average Word Count: <span id="avgWordCount">0</span></p>
                            <p>With Emojis: <span id="emojiCount">0</span></p>
                            <p>With Questions: <span id="questionCount">0</span></p>
                            <p>With Exclamations: <span id="exclamationCount">0</span></p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Charts Section - Row 1: Sentiment Analysis -->
            <section>
                <h2>üìà Sentiment Analysis Patterns</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    Visual breakdown of how your algorithm classifies sentiment and how confident it is about different sentiment types.
                </p>
                <div class="charts-row">
                    <div class="chart-container">
                        <h3>üé≠ Sentiment Distribution</h3>
                        <div class="chart-description">
                            Shows the overall balance of positive, negative, and neutral classifications. A balanced distribution suggests the algorithm isn't biased toward any particular sentiment, while skewed distributions may indicate dataset bias or algorithm preferences.
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="sentimentChart" width="300" height="150"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <h3>üéØ Confidence by Sentiment</h3>
                        <div class="chart-description">
                            Reveals which sentiment types your algorithm is most confident about. Higher bars indicate the algorithm has clearer decision boundaries for those sentiments. Lower confidence may suggest ambiguous language or training data gaps.
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="confidenceSentimentChart" width="300" height="150"></canvas>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Charts Section - Row 2: Confidence Analysis -->
            <section>
                <h2>üîç Confidence Analysis</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    Deep dive into your algorithm's confidence patterns and how text characteristics affect prediction certainty.
                </p>
                <div class="charts-row">
                    <div class="chart-container">
                        <h3>üìä Confidence Score Distribution</h3>
                        <div class="chart-description">
                            Histogram showing the spread of confidence scores. A bell curve centered on high values indicates consistent performance. Multiple peaks or low-centered distributions suggest uncertainty or edge cases that need attention.
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="confidenceChart" width="300" height="150"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <h3>üìè Text Length vs Confidence</h3>
                        <div class="chart-description">
                            Scatter plot revealing if text length affects prediction confidence. Upward trends suggest the algorithm benefits from more context, while downward trends indicate shorter texts are easier to classify.
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="lengthConfidenceChart" width="300" height="150"></canvas>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Charts Section - Row 3: Feature & Temporal Analysis -->
            <section>
                <h2>üî¨ Feature & Temporal Analysis</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    Analysis of how specific text features and timing patterns influence your algorithm's predictions and confidence levels.
                </p>
                <div class="charts-row">
                    <div class="chart-container">
                        <h3>üî• Feature Impact on Confidence</h3>
                        <div class="chart-description">
                            Shows how different text features (emojis, questions, caps, length) affect prediction confidence. Higher bars indicate features that help the algorithm make more confident decisions. Use this to understand what signals your model relies on.
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="featureChart" width="300" height="150"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <h3>‚è∞ Temporal Patterns</h3>
                        <div class="chart-description">
                            Time-based analysis of predictions (hourly or daily patterns if timestamp data is available). Can reveal if sentiment patterns change over time or if certain periods produce more confident predictions.
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="temporalChart" width="300" height="150"></canvas>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Sample Predictions -->
            <section id="samplePredictions">
                <h2>üîç Sample Predictions Analysis</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    Representative examples across different confidence levels to understand how your algorithm makes decisions. High confidence examples show clear cases, while low confidence examples reveal edge cases and potential improvement areas.
                </p>
                <table id="predictionsTable">
                    <thead>
                        <tr>
                            <th style="width: 40%;">Text Sample</th>
                            <th style="width: 12%;">Prediction</th>
                            <th style="width: 12%;">Confidence</th>
                            <th style="width: 10%;">Words</th>
                            <th style="width: 15%;">Features Detected</th>
                            <th style="width: 31%;">Algorithm Analysis</th>
                        </tr>
                    </thead>
                    <tbody id="predictionsBody">
                        <!-- Table rows will be populated here -->
                    </tbody>
                </table>
            </section>

            <!-- Insights -->
            <section id="insights">
                <h2>üí° Algorithm Insights & Recommendations</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    AI-generated analysis of your algorithm's behavior patterns, strengths, weaknesses, and actionable recommendations for improvement.
                </p>
                <div id="insightsContent">
                    <!-- Insights will be populated here -->
                </div>
            </section>

        </div>

        <div class="section-nav">
            üìä Scroll to explore sections
        </div>
    </div>

    <script>
        let data = [];
        let algorithmName = 'Unknown Algorithm';
        let algorithmType = 'unknown';
        let charts = {};

        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            document.getElementById('loading').style.display = 'block';
            document.getElementById('content').style.display = 'none';
            document.getElementById('error').style.display = 'none';

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const csv = event.target.result;
                    const parsed = Papa.parse(csv, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true
                    });

                    data = parsed.data.filter(row => row.text && row.text.trim());

                    if (data.length === 0) {
                        throw new Error('No valid data found in CSV file.');
                    }

                    detectAlgorithmInfo();
                    console.log(`Loaded ${data.length} predictions from ${algorithmName}`);

                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('content').style.display = 'block';

                    generateDashboard();

                } catch (error) {
                    console.error('Error processing file:', error);
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Error processing file: ${error.message}`;
                }
            };
            reader.readAsText(file);
        });

        function detectAlgorithmInfo() {
            const firstRow = data[0];

            if (firstRow.model_name) {
                algorithmName = firstRow.model_name;
            } else if (firstRow.algorithm) {
                algorithmName = firstRow.algorithm;
            } else {
                algorithmName = 'ML Algorithm';
            }

            if (firstRow.model_type) {
                algorithmType = firstRow.model_type;
            } else if (algorithmName.includes('bert') || algorithmName.includes('roberta') || algorithmName.includes('lstm') || algorithmName.includes('neural')) {
                algorithmType = 'neural';
            } else {
                algorithmType = 'traditional';
            }
        }

        function getConfidence(row) {
            return row.ml_confidence || row.confidence || row.conf || 0;
        }

        function getSentiment(row) {
            return row.ml_sentiment || row.sentiment || row.prediction || row.final_sentiment || 'neutral';
        }

        function generateDashboard() {
            updateSummaryStats();
            updatePerformanceMetrics();
            generateCharts();
            generateSamplePredictions();
            generateInsights();
        }

        function updateSummaryStats() {
            const totalPredictions = data.length;
            const avgConfidence = data.reduce((sum, row) => sum + (getConfidence(row) || 0), 0) / totalPredictions;

            document.getElementById('algorithmName').textContent = algorithmName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            document.getElementById('algorithmType').textContent = algorithmType.charAt(0).toUpperCase() + algorithmType.slice(1);
            document.getElementById('totalPredictions').textContent = totalPredictions.toLocaleString();
            document.getElementById('avgConfidence').textContent = (avgConfidence * 100).toFixed(1) + '%';
        }

        function updatePerformanceMetrics() {
            const totalPredictions = data.length;

            // Confidence distribution
            const highConfidenceCount = data.filter(row => (getConfidence(row) || 0) > 0.8).length;
            const mediumConfidenceCount = data.filter(row => {
                const conf = getConfidence(row) || 0;
                return conf > 0.5 && conf <= 0.8;
            }).length;
            const lowConfidenceCount = totalPredictions - highConfidenceCount - mediumConfidenceCount;

            document.getElementById('highConfidence').textContent = `${highConfidenceCount} (${((highConfidenceCount / totalPredictions) * 100).toFixed(1)}%)`;
            document.getElementById('mediumConfidence').textContent = `${mediumConfidenceCount} (${((mediumConfidenceCount / totalPredictions) * 100).toFixed(1)}%)`;
            document.getElementById('lowConfidence').textContent = `${lowConfidenceCount} (${((lowConfidenceCount / totalPredictions) * 100).toFixed(1)}%)`;

            // Sentiment distribution
            const sentimentCounts = {
                positive: data.filter(row => getSentiment(row) === 'positive').length,
                negative: data.filter(row => getSentiment(row) === 'negative').length,
                neutral: data.filter(row => getSentiment(row) === 'neutral').length
            };

            document.getElementById('positiveCount').textContent = `${sentimentCounts.positive} (${((sentimentCounts.positive / totalPredictions) * 100).toFixed(1)}%)`;
            document.getElementById('negativeCount').textContent = `${sentimentCounts.negative} (${((sentimentCounts.negative / totalPredictions) * 100).toFixed(1)}%)`;
            document.getElementById('neutralCount').textContent = `${sentimentCounts.neutral} (${((sentimentCounts.neutral / totalPredictions) * 100).toFixed(1)}%)`;

            // Text features
            const avgWordCount = data.reduce((sum, row) => sum + (row.word_count || 0), 0) / totalPredictions;
            const emojiCount = data.filter(row => (row.emoji_count || 0) > 0).length;
            const questionCount = data.filter(row => row.has_question || (row.text && row.text.includes('?'))).length;
            const exclamationCount = data.filter(row => row.has_exclamation || (row.text && row.text.includes('!'))).length;

            document.getElementById('avgWordCount').textContent = avgWordCount.toFixed(1);
            document.getElementById('emojiCount').textContent = `${emojiCount} (${((emojiCount / totalPredictions) * 100).toFixed(1)}%)`;
            document.getElementById('questionCount').textContent = `${questionCount} (${((questionCount / totalPredictions) * 100).toFixed(1)}%)`;
            document.getElementById('exclamationCount').textContent = `${exclamationCount} (${((exclamationCount / totalPredictions) * 100).toFixed(1)}%)`;
        }

        function generateCharts() {
            generateSentimentChart();
            generateConfidenceChart();
            generateConfidenceSentimentChart();
            generateLengthConfidenceChart();
            generateFeatureChart();
            generateTemporalChart();
        }

        function generateSentimentChart() {
            const sentimentCounts = {
                positive: data.filter(row => getSentiment(row) === 'positive').length,
                negative: data.filter(row => getSentiment(row) === 'negative').length,
                neutral: data.filter(row => getSentiment(row) === 'neutral').length
            };

            const ctx = document.getElementById('sentimentChart').getContext('2d');
            if (charts.sentiment) charts.sentiment.destroy();

            charts.sentiment = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Positive', 'Negative', 'Neutral'],
                    datasets: [{
                        data: [sentimentCounts.positive, sentimentCounts.negative, sentimentCounts.neutral],
                        backgroundColor: ['#22c55e', '#ef4444', '#6b7280'],
                        borderWidth: 3,
                        borderColor: '#ffffff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 20,
                                font: { size: 14 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((context.parsed / total) * 100).toFixed(1);
                                    return `${context.label}: ${context.parsed} predictions (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function generateConfidenceChart() {
            const confidenceScores = data.map(row => getConfidence(row) || 0);
            const bins = 15;
            const max = Math.max(...confidenceScores);
            const min = Math.min(...confidenceScores);
            const binSize = (max - min) / bins;

            const histogram = new Array(bins).fill(0);
            const labels = [];

            for (let i = 0; i < bins; i++) {
                const binStart = min + i * binSize;
                const binEnd = binStart + binSize;
                labels.push(`${(binStart * 100).toFixed(0)}-${(binEnd * 100).toFixed(0)}%`);

                confidenceScores.forEach(score => {
                    if (score >= binStart && (score < binEnd || (i === bins - 1 && score === max))) {
                        histogram[i]++;
                    }
                });
            }

            const ctx = document.getElementById('confidenceChart').getContext('2d');
            if (charts.confidence) charts.confidence.destroy();

            charts.confidence = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Predictions',
                        data: histogram,
                        backgroundColor: '#6366f1',
                        borderColor: '#4f46e5',
                        borderWidth: 1,
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Confidence Score Range', font: { size: 14 } },
                            ticks: { font: { size: 11 } }
                        },
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Number of Predictions', font: { size: 14 } }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.parsed.y} predictions in this confidence range`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function generateConfidenceSentimentChart() {
            const sentimentConfidence = {
                positive: data.filter(row => getSentiment(row) === 'positive').map(row => getConfidence(row) || 0),
                negative: data.filter(row => getSentiment(row) === 'negative').map(row => getConfidence(row) || 0),
                neutral: data.filter(row => getSentiment(row) === 'neutral').map(row => getConfidence(row) || 0)
            };

            const avgConfidence = {
                positive: sentimentConfidence.positive.reduce((a, b) => a + b, 0) / sentimentConfidence.positive.length || 0,
                negative: sentimentConfidence.negative.reduce((a, b) => a + b, 0) / sentimentConfidence.negative.length || 0,
                neutral: sentimentConfidence.neutral.reduce((a, b) => a + b, 0) / sentimentConfidence.neutral.length || 0
            };

            const ctx = document.getElementById('confidenceSentimentChart').getContext('2d');
            if (charts.confidenceSentiment) charts.confidenceSentiment.destroy();

            charts.confidenceSentiment = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Positive', 'Negative', 'Neutral'],
                    datasets: [{
                        label: 'Average Confidence',
                        data: [avgConfidence.positive, avgConfidence.negative, avgConfidence.neutral],
                        backgroundColor: ['#22c55e', '#ef4444', '#6b7280'],
                        borderRadius: 6,
                        borderWidth: 2,
                        borderColor: ['#16a34a', '#dc2626', '#4b5563']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1.0,
                            title: { display: true, text: 'Average Confidence Score', font: { size: 14 } },
                            ticks: {
                                callback: function(value) {
                                    return (value * 100).toFixed(0) + '%';
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const sentiment = context.label.toLowerCase();
                                    const count = sentimentConfidence[sentiment].length;
                                    return `${context.label}: ${(context.parsed.y * 100).toFixed(1)}% avg confidence (${count} predictions)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function generateLengthConfidenceChart() {
            const lengthConfidenceData = data.map(row => ({
                x: row.word_count || row.text?.split(' ').length || 0,
                y: getConfidence(row) || 0,
                sentiment: getSentiment(row)
            })).filter(d => d.x > 0);

            const ctx = document.getElementById('lengthConfidenceChart').getContext('2d');
            if (charts.lengthConfidence) charts.lengthConfidence.destroy();

            charts.lengthConfidence = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Text Length vs Confidence',
                        data: lengthConfidenceData,
                        backgroundColor: function(context) {
                            const sentiment = lengthConfidenceData[context.dataIndex]?.sentiment;
                            return sentiment === 'positive' ? '#22c55e80' :
                                   sentiment === 'negative' ? '#ef444480' : '#6b728080';
                        },
                        borderColor: function(context) {
                            const sentiment = lengthConfidenceData[context.dataIndex]?.sentiment;
                            return sentiment === 'positive' ? '#22c55e' :
                                   sentiment === 'negative' ? '#ef4444' : '#6b7280';
                        },
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Word Count', font: { size: 14 } }
                        },
                        y: {
                            title: { display: true, text: 'Confidence Score', font: { size: 14 } },
                            min: 0,
                            max: 1,
                            ticks: {
                                callback: function(value) {
                                    return (value * 100).toFixed(0) + '%';
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = lengthConfidenceData[context.dataIndex];
                                    return `${context.parsed.x} words, ${(context.parsed.y * 100).toFixed(1)}% confidence, ${point.sentiment} sentiment`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function generateFeatureChart() {
            const features = {
                'Has Emojis': data.filter(row => (row.emoji_count || 0) > 0),
                'Has Questions': data.filter(row => row.has_question || (row.text && row.text.includes('?'))),
                'Has Exclamations': data.filter(row => row.has_exclamation || (row.text && row.text.includes('!'))),
                'ALL CAPS Text': data.filter(row => row.has_caps || (row.text && /[A-Z]{3,}/.test(row.text))),
                'Long Text (>50w)': data.filter(row => (row.word_count || 0) > 50),
                'Short Text (<10w)': data.filter(row => (row.word_count || 0) < 10)
            };

            const featureData = Object.entries(features).map(([feature, subset]) => {
                const avgConfidence = subset.reduce((sum, row) => sum + (getConfidence(row) || 0), 0) / subset.length || 0;
                return {
                    feature,
                    avgConfidence: avgConfidence * 100,
                    count: subset.length
                };
            }).filter(d => d.count > 0);

            const ctx = document.getElementById('featureChart').getContext('2d');
            if (charts.feature) charts.feature.destroy();

            charts.feature = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: featureData.map(d => d.feature),
                    datasets: [{
                        label: 'Average Confidence (%)',
                        data: featureData.map(d => d.avgConfidence),
                        backgroundColor: '#22c55e',
                        borderColor: '#16a34a',
                        borderWidth: 2,
                        borderRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Text Features', font: { size: 14 } },
                            ticks: {
                                maxRotation: 45,
                                font: { size: 11 }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: { display: true, text: 'Average Confidence (%)', font: { size: 14 } }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const feature = featureData[context.dataIndex];
                                    return `${feature.feature}: ${context.parsed.y.toFixed(1)}% avg confidence (${feature.count} samples)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function generateTemporalChart() {
            const hasTimestamp = data.some(row => row.timestamp || row.hour !== undefined);

            const ctx = document.getElementById('temporalChart').getContext('2d');
            if (charts.temporal) charts.temporal.destroy();

            if (!hasTimestamp) {
                charts.temporal = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['No temporal data available in your dataset'],
                        datasets: [{
                            label: 'No temporal data found',
                            data: [0],
                            backgroundColor: '#9ca3af'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false }
                        },
                        scales: {
                            y: { display: false },
                            x: {
                                ticks: { font: { size: 12 } }
                            }
                        }
                    }
                });
                return;
            }

            if (data.some(row => row.hour !== undefined && row.hour !== null)) {
                const hourlyData = Array(24).fill(0).map(() => ({
                    positive: 0, negative: 0, neutral: 0
                }));

                data.forEach(row => {
                    if (row.hour !== undefined && row.hour !== null) {
                        const hour = parseInt(row.hour);
                        if (hour >= 0 && hour < 24) {
                            const sentiment = getSentiment(row);
                            hourlyData[hour][sentiment]++;
                        }
                    }
                });

                charts.temporal = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: Array.from({length: 24}, (_, i) => `${i}:00`),
                        datasets: [
                            {
                                label: 'Positive',
                                data: hourlyData.map(h => h.positive),
                                borderColor: '#22c55e',
                                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                                tension: 0.4,
                                borderWidth: 2
                            },
                            {
                                label: 'Negative',
                                data: hourlyData.map(h => h.negative),
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                tension: 0.4,
                                borderWidth: 2
                            },
                            {
                                label: 'Neutral',
                                data: hourlyData.map(h => h.neutral),
                                borderColor: '#6b7280',
                                backgroundColor: 'rgba(107, 114, 128, 0.1)',
                                tension: 0.4,
                                borderWidth: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: { display: true, text: 'Hour of Day', font: { size: 14 } }
                            },
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'Number of Predictions', font: { size: 14 } }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: { font: { size: 12 } }
                            }
                        }
                    }
                });
            }
        }

        function generateSamplePredictions() {
            const tableBody = document.getElementById('predictionsBody');

            const highConfidence = data.filter(row => (getConfidence(row) || 0) > 0.8).slice(0, 3);
            const mediumConfidence = data.filter(row => {
                const conf = getConfidence(row) || 0;
                return conf > 0.5 && conf <= 0.8;
            }).slice(0, 3);
            const lowConfidence = data.filter(row => (getConfidence(row) || 0) <= 0.5).slice(0, 3);

            const sampleData = [...highConfidence, ...mediumConfidence, ...lowConfidence];

            tableBody.innerHTML = sampleData.map(row => {
                const sentiment = getSentiment(row);
                const confidence = getConfidence(row) || 0;
                const features = [];

                if (row.emoji_count && row.emoji_count > 0) features.push(`${row.emoji_count} emojis`);
                if (row.has_question || (row.text && row.text.includes('?'))) features.push('question');
                if (row.has_exclamation || (row.text && row.text.includes('!'))) features.push('exclamation');
                if (row.has_caps || (row.text && /[A-Z]{3,}/.test(row.text))) features.push('caps');

                const analysis = generateAnalysis(row, sentiment, confidence, features);
                const confidenceClass = confidence > 0.8 ? 'high' : confidence > 0.5 ? 'medium' : 'low';

                return `
                    <tr style="border-left: 4px solid ${sentiment === 'positive' ? '#22c55e' : sentiment === 'negative' ? '#ef4444' : '#6b7280'};">
                        <td style="font-style: italic;">"${(row.text || '').substring(0, 120)}${row.text && row.text.length > 120 ? '...' : ''}"</td>
                        <td style="font-weight: 600; color: ${sentiment === 'positive' ? '#16a34a' : sentiment === 'negative' ? '#dc2626' : '#4b5563'};">${sentiment}</td>
                        <td style="font-weight: 600; color: ${confidence > 0.8 ? '#16a34a' : confidence > 0.5 ? '#d97706' : '#dc2626'};">${(confidence * 100).toFixed(1)}%</td>
                        <td>${row.word_count || row.text?.split(' ').length || 0}</td>
                        <td style="font-size: 0.9em;">${features.join(', ') || 'none'}</td>
                        <td style="font-size: 0.9em; color: #555;">${analysis}</td>
                    </tr>
                `;
            }).join('');
        }

        function generateAnalysis(row, sentiment, confidence, features) {
            let analysis = '';

            if (confidence > 0.8) {
                analysis = `Strong ${sentiment} signals detected - `;
                if (sentiment === 'positive') {
                    analysis += 'clear positive language patterns';
                } else if (sentiment === 'negative') {
                    analysis += 'obvious negative sentiment indicators';
                } else {
                    analysis += 'balanced, neutral tone identified';
                }
            } else if (confidence > 0.5) {
                analysis = `Moderate ${sentiment} classification - `;
                if (features.length > 0) {
                    analysis += `mixed signals with ${features.join(', ')}`;
                } else {
                    analysis += 'ambiguous language patterns';
                }
            } else {
                analysis = 'Low confidence prediction - ';
                analysis += 'unclear sentiment indicators, potential edge case requiring review';
            }

            if (features.includes('emojis')) {
                analysis += ', emoji context considered';
            }
            if (features.includes('caps')) {
                analysis += ', emphasized text detected';
            }

            return analysis;
        }

        function generateInsights() {
            const insightsContainer = document.getElementById('insightsContent');

            const totalPredictions = data.length;
            const avgConfidence = data.reduce((sum, row) => sum + (getConfidence(row) || 0), 0) / totalPredictions;

            const sentimentCounts = {
                positive: data.filter(row => getSentiment(row) === 'positive').length,
                negative: data.filter(row => getSentiment(row) === 'negative').length,
                neutral: data.filter(row => getSentiment(row) === 'neutral').length
            };

            const highConfidenceRate = (data.filter(row => (getConfidence(row) || 0) > 0.8).length / totalPredictions) * 100;

            const insights = [];

            // Performance overview
            insights.push({
                title: 'üéØ Algorithm Performance Overview',
                content: `${algorithmName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} processed ${totalPredictions.toLocaleString()} predictions with an average confidence of ${(avgConfidence * 100).toFixed(1)}%. ${highConfidenceRate > 60 ? 'The algorithm demonstrates strong confidence in most predictions, indicating reliable performance and clear decision boundaries.' : highConfidenceRate > 30 ? 'The algorithm shows moderate confidence levels, suggesting it handles most cases well but encounters uncertainty in some scenarios.' : 'Lower confidence levels indicate the algorithm may benefit from additional training data, feature engineering, or model architecture improvements.'}`
            });

            // Sentiment distribution analysis
            const dominantSentiment = Object.entries(sentimentCounts).reduce((a, b) => sentimentCounts[a[0]] > sentimentCounts[b[0]] ? a : b)[0];
            const sentimentBalance = Math.max(...Object.values(sentimentCounts)) / Math.min(...Object.values(sentimentCounts));

            insights.push({
                title: 'üí≠ Sentiment Classification Patterns',
                content: `The algorithm classified ${((sentimentCounts.positive / totalPredictions) * 100).toFixed(1)}% as positive, ${((sentimentCounts.negative / totalPredictions) * 100).toFixed(1)}% as negative, and ${((sentimentCounts.neutral / totalPredictions) * 100).toFixed(1)}% as neutral. ${sentimentBalance > 3 ? `Strong bias toward ${dominantSentiment} sentiment detected - this could indicate dataset imbalance or algorithmic bias that may need addressing.` : sentimentBalance > 2 ? `Moderate skew toward ${dominantSentiment} sentiment observed, which may reflect natural patterns in your data.` : 'Relatively balanced sentiment distribution across categories, suggesting the algorithm isn\'t biased toward any particular sentiment.'}`
            });

            // Confidence by sentiment analysis
            const confidenceBysentiment = {
                positive: data.filter(row => getSentiment(row) === 'positive').map(row => getConfidence(row) || 0),
                negative: data.filter(row => getSentiment(row) === 'negative').map(row => getConfidence(row) || 0),
                neutral: data.filter(row => getSentiment(row) === 'neutral').map(row => getConfidence(row) || 0)
            };

            const avgConfidenceBysentiment = Object.entries(confidenceBysentiment).map(([sentiment, confidences]) => ({
                sentiment,
                avgConfidence: confidences.reduce((a, b) => a + b, 0) / confidences.length || 0
            }));

            const mostConfidentsentiment = avgConfidenceBysentiment.reduce((a, b) => a.avgConfidence > b.avgConfidence ? a : b);
            const leastConfidentsentiment = avgConfidenceBysentiment.reduce((a, b) => a.avgConfidence < b.avgConfidence ? a : b);

            insights.push({
                title: 'üîç Confidence Patterns by Sentiment',
                content: `The algorithm is most confident when predicting ${mostConfidentsentiment.sentiment} sentiment (${(mostConfidentsentiment.avgConfidence * 100).toFixed(1)}% avg confidence) and least confident with ${leastConfidentsentiment.sentiment} sentiment (${(leastConfidentsentiment.avgConfidence * 100).toFixed(1)}% avg confidence). ${mostConfidentsentiment.avgConfidence - leastConfidentsentiment.avgConfidence > 0.2 ? 'This significant confidence gap suggests the algorithm has clearer decision boundaries for some sentiments than others, possibly due to training data imbalances or inherent difficulty in classifying certain sentiment types.' : 'Confidence levels are relatively consistent across sentiments, indicating balanced performance.'}`
            });

            // Feature impact
            const emojiData = data.filter(row => (row.emoji_count || 0) > 0);
            const noEmojiData = data.filter(row => (row.emoji_count || 0) === 0);

            if (emojiData.length > 0 && noEmojiData.length > 0) {
                const emojiConfidence = emojiData.reduce((sum, row) => sum + (getConfidence(row) || 0), 0) / emojiData.length;
                const noEmojiConfidence = noEmojiData.reduce((sum, row) => sum + (getConfidence(row) || 0), 0) / noEmojiData.length;

                insights.push({
                    title: 'üòä Emoji Impact Analysis',
                    content: `Predictions with emojis (${emojiData.length} samples) have ${(emojiConfidence * 100).toFixed(1)}% average confidence compared to ${(noEmojiConfidence * 100).toFixed(1)}% for text without emojis. ${emojiConfidence > noEmojiConfidence ? 'Emojis appear to help the algorithm make more confident predictions, likely providing clear sentiment signals that complement textual analysis.' : 'Emojis may introduce complexity that reduces prediction confidence, suggesting the algorithm might not be well-trained on emoji patterns or that emojis create ambiguous contexts.'}`
                });
            }

            // Text length analysis
            const shortTexts = data.filter(row => (row.word_count || 0) < 10);
            const longTexts = data.filter(row => (row.word_count || 0) > 30);

            if (shortTexts.length > 0 && longTexts.length > 0) {
                const shortConfidence = shortTexts.reduce((sum, row) => sum + (getConfidence(row) || 0), 0) / shortTexts.length;
                const longConfidence = longTexts.reduce((sum, row) => sum + (getConfidence(row) || 0), 0) / longTexts.length;

                insights.push({
                    title: 'üìè Text Length Impact',
                    content: `Short texts (<10 words, ${shortTexts.length} samples) receive ${(shortConfidence * 100).toFixed(1)}% average confidence, while longer texts (>30 words, ${longTexts.length} samples) receive ${(longConfidence * 100).toFixed(1)}%. ${longConfidence > shortConfidence ? 'The algorithm performs better with more context, as longer texts provide more sentiment indicators and linguistic patterns to analyze.' : 'Shorter texts may be easier to classify due to concentrated sentiment signals, while longer texts introduce complexity and potentially conflicting signals that reduce confidence.'}`
                });
            }

            // Algorithm type insights
            if (algorithmType === 'neural') {
                insights.push({
                    title: 'üß† Neural Network Behavior',
                    content: `As a neural network, this algorithm likely learned complex, non-linear patterns in your data through deep learning techniques. ${avgConfidence > 0.7 ? 'High confidence levels suggest the network has successfully learned robust feature representations and can capture subtle contextual cues.' : 'Lower confidence may indicate the need for more training data, architectural adjustments, regularization techniques, or hyperparameter tuning.'} Neural networks excel at capturing nuanced linguistic patterns but can be less interpretable than traditional methods, making it harder to understand exactly why specific decisions are made.`
                });
            } else {
                insights.push({
                    title: '‚öôÔ∏è Traditional Algorithm Behavior',
                    content: `This traditional machine learning approach relies on explicit feature engineering and statistical patterns rather than learned representations. ${avgConfidence > 0.7 ? 'Strong performance suggests well-designed features that effectively capture sentiment-relevant characteristics of your text data.' : 'Consider feature engineering improvements such as n-grams, part-of-speech tagging, sentiment lexicons, or domain-specific features.'} Traditional algorithms offer better interpretability and typically faster inference times than neural approaches, making them easier to debug and deploy.`
                });
            }

            // Recommendations
            const recommendations = [];

            if (avgConfidence < 0.6) {
                recommendations.push('Consider collecting more diverse training data or improving data quality through better labeling and preprocessing');
            }
            if (highConfidenceRate < 30) {
                recommendations.push('Review edge cases and consider ensemble methods that combine multiple algorithms for better performance');
            }
            if (sentimentBalance > 3) {
                recommendations.push('Address dataset imbalance through techniques like resampling, class weighting, or collecting more examples of underrepresented sentiments');
            }
            if (algorithmType === 'traditional' && avgConfidence < 0.7) {
                recommendations.push('Experiment with additional features like sentiment lexicons, semantic embeddings, or domain-specific linguistic patterns');
            }
            if (algorithmType === 'neural' && avgConfidence < 0.7) {
                recommendations.push('Try architectural improvements, regularization techniques, transfer learning, or fine-tuning on domain-specific data');
            }

            recommendations.push('Consider A/B testing this algorithm against other approaches to validate production readiness and comparative performance');

            insights.push({
                title: 'üí° Optimization Recommendations',
                content: recommendations.length > 1 ? recommendations.join(' ‚Ä¢ ') : 'Algorithm performance appears strong across most metrics - focus on monitoring edge cases and continuous improvement through feedback loops.'
            });

            insightsContainer.innerHTML = insights.map(insight => `
                <div class="insight-item">
                    <h3>${insight.title}</h3>
                    <p>${insight.content}</p>
                </div>
            `).join('');
        }
    </script>
</body>
</html>